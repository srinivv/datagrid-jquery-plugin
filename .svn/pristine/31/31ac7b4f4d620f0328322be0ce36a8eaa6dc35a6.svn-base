package com.cisco.apas.util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.text.ParsePosition;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.StringTokenizer;

public class DateUtils {
	
	public static SimpleDateFormat dateFormat1 = new SimpleDateFormat("MM/dd/yyyy");

	public static SimpleDateFormat dateFormat = new SimpleDateFormat("dd-MMM-yyyy");

	public static SimpleDateFormat dateTimeFormat = new SimpleDateFormat("dd-MMM-yyyy / h:mm");

	public static SimpleDateFormat dateFormat2 = new SimpleDateFormat("dd MMM yyyy");

	public static SimpleDateFormat dateFormat3 = new SimpleDateFormat("yyyy-MM-dd");
	
	public static SimpleDateFormat dateFormat4 = new SimpleDateFormat("yyyyMMddHHmmss");
	
	public static HashMap<String, String> monthMap = null;
	
	static {
		monthMap = new HashMap<String, String>();
		monthMap.put("JAN", "1");
		monthMap.put("FEB", "2");
		monthMap.put("MAR", "3");
		monthMap.put("APR", "4");
		monthMap.put("MAY", "5");
		monthMap.put("JUN", "6");
		monthMap.put("JUL", "7");
		monthMap.put("AUG", "8");
		monthMap.put("SEP", "9");
		monthMap.put("OCT", "10");
		monthMap.put("NOV", "11");
		monthMap.put("DEC", "12");
		dateFormat1.setLenient(false);
		dateFormat.setLenient(false);
		dateTimeFormat.setLenient(false);
		dateFormat2.setLenient(false);
	}

	public static java.util.Date convertDate(java.sql.Date sqlDate) {
		if (sqlDate == null) {
			return null;
		}

		return new java.util.Date(sqlDate.getTime());
	}

	public static java.sql.Date convertDate(java.util.Date date) {
		if (date == null) {
			return null;
		}

		return new java.sql.Date(date.getTime());
	}

	public static String formatDate(Date date) {
		if (date == null) {
			return null;
		}
		return dateFormat.format(date);
	}

	public static String formatUIDate(Date date) {
		if (date == null) {
			return null;
		}
		return dateFormat1.format(date);
	}
	
	public static Date formatDate1(String date) {
		if (date == null) {
			return null;
		}
		try {
			dateFormat1.setLenient(false);
			return dateFormat1.parse(date);
		} catch (ParseException e) {
			return null;
		}
	}

	public static String formatDatetoDB(String date) {
		if(date==null)return null;
		try {
			return dateFormat1.format(dateFormat3.parse(date));
		} catch (ParseException e) {
			return null;
		}
	}
	
	public static Date extractDate(String dateString) {
		try {

			if (dateString.indexOf("-") == -1) {
				return dateFormat2.parse(dateString);
			}
			return dateFormat.parse(dateString);
		} catch (ParseException e) {
		}
		return null;
	}

	public static java.sql.Date convertStrToSqlDt(String dateStr) throws Exception {

		java.sql.Date sqlDt = null;
		if (dateStr != null && (!dateStr.trim().equals(""))) {

			SimpleDateFormat dateFormat = new SimpleDateFormat("dd-MMM-yyyy");
			dateFormat.setLenient(false);
			ParsePosition pos = new ParsePosition(0);

			java.util.Date uDt = dateFormat.parse(dateStr, pos);

			// To prevent bad data, ad additional check that will throw exception
			// if the year is < 1970 or Year > 2070
			GregorianCalendar gregCalInst = new GregorianCalendar();
			gregCalInst.setTime(uDt);
			int currYr = gregCalInst.get(Calendar.YEAR);

			if (currYr < 1970 || currYr > 2070) {
				throw new Exception("Current year is either < 1970 or > 2070");
			}

			sqlDt = new java.sql.Date(uDt.getTime());
		}

		return sqlDt;
	}

	public static String formatDateTime(Date date) {
		if (date == null) {
			return null;
		}
		return dateTimeFormat.format(date);
	}

	public static String convertDate(String date) {
		String convertedDate = null;
		if (date != null && !"".equals(date)) {

			StringTokenizer tokenizer = new StringTokenizer(date, "/");
			int count = tokenizer.countTokens();
			String datePart[] = new String[count];

			for (int i = 0; i < count; i++) {
				datePart[i] = tokenizer.nextToken();

			}
			StringBuffer sb = new StringBuffer();
			sb.append(datePart[1]);
			sb.append("-");
			sb.append(getMonth(datePart[0]));
			sb.append("-");
			sb.append(datePart[2]);
			convertedDate = sb.toString();
		}
		return convertedDate;
	}

	public static String getMonth(String monthNumber) {
		String returnValue = null;
		switch (Integer.parseInt(monthNumber)) {
		case 1:
			returnValue = "JAN";
			break;
		case 2:
			returnValue = "FEB";
			break;
		case 3:
			returnValue = "MAR";
			break;
		case 4:
			returnValue = "APR";
			break;
		case 5:
			returnValue = "MAY";
			break;
		case 6:
			returnValue = "JUN";
			break;
		case 7:
			returnValue = "JUL";
			break;
		case 8:
			returnValue = "AUG";
			break;
		case 9:
			returnValue = "SEP";
			break;
		case 10:
			returnValue = "OCT";
			break;
		case 11:
			returnValue = "NOV";
			break;
		case 12:
			returnValue = "DEC";
			break;

		}
		;
		return returnValue;
	}

	public static String convertDateBack(String date) {
		String convertedDate = null;
		if (date != null && !"".equals(date)) {

			StringTokenizer tokenizer = new StringTokenizer(date, "-");
			int count = tokenizer.countTokens();
			String datePart[] = new String[count];

			for (int i = 0; i < count; i++) {
				datePart[i] = tokenizer.nextToken();

			}
			StringBuffer sb = new StringBuffer();
			sb.append(getMonthNumber(datePart[1]));
			sb.append("/");
			sb.append(datePart[0]);
			sb.append("/");
			sb.append(datePart[2]);
			convertedDate = sb.toString();
		}
		return convertedDate;

	}

	public static String getMonthNumber(String month) {
		return (String) monthMap.get(month.toUpperCase());
	}
}
