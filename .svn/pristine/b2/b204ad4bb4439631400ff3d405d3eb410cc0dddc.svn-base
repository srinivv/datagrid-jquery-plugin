package com.cisco.apas.dao;

import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.Date;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;

import oracle.jdbc.driver.OracleTypes;
import oracle.sql.ARRAY;
import oracle.sql.ArrayDescriptor;
import oracle.sql.STRUCT;
import oracle.sql.StructDescriptor;

import org.apache.log4j.Logger;
import org.hibernate.criterion.Order;
import org.hibernate.criterion.Projections;
import org.hibernate.criterion.Restrictions;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.SqlOutParameter;
import org.springframework.jdbc.core.SqlParameter;
import org.springframework.jdbc.core.support.AbstractSqlTypeValue;
import org.springframework.jdbc.object.StoredProcedure;
import org.springframework.util.StopWatch;



import com.cisco.apas.entity.AndCondition;
import com.cisco.apas.entity.Authorization;
import com.cisco.apas.entity.Certification;
import com.cisco.apas.entity.ConditionalToken;
import com.cisco.apas.entity.Country;
import com.cisco.apas.entity.EndToken;
import com.cisco.apas.entity.Expression;
import com.cisco.apas.entity.ExpressionType;
import com.cisco.apas.entity.InCondition;
import com.cisco.apas.entity.Leaf;
import com.cisco.apas.entity.LeafExpressionValidator;
import com.cisco.apas.entity.OrCondition;
import com.cisco.apas.entity.ParenthesisToken;
import com.cisco.apas.entity.PartnerType;
import com.cisco.apas.entity.PartnerTypeExpressionValidator;
import com.cisco.apas.entity.Rule;
import com.cisco.apas.entity.Scenario;
import com.cisco.apas.entity.Specialization;
import com.cisco.apas.entity.StartToken;
import com.cisco.apas.entity.Token;

public class RuleDao extends BaseDao implements DataAccessQueries {
	private static final Logger logger = Logger.getLogger(RuleDao.class);
	private static final String sql_QUALIFICATIONS = "select qual_type from sd_partner_qualification where qual_code=?";

	public int getRulesCount(){
		try {
			final org.hibernate.Criteria criteria = this.getSession(false).createCriteria(Rule.class).add(Restrictions.ne("ruleStatus", "I"));
			criteria.setProjection(Projections.rowCount());
			return (Integer) criteria.uniqueResult();
		} catch (org.hibernate.HibernateException ex) {
			throw super.convertHibernateAccessException(ex);
		}
	}

	public List<Rule> getAllRules(int start, int end, int pageSize) {
		try {
			final org.hibernate.Criteria criteria = this.getSession(false).createCriteria(Rule.class).addOrder(Order.desc("updatedOn")).add(Restrictions.ne("ruleStatus", "I"));
			criteria.setFirstResult(start-1);
			criteria.setMaxResults(pageSize);
			List<Rule> results = criteria.list();
			return results;
		} catch (org.hibernate.HibernateException ex) {
			throw super.convertHibernateAccessException(ex);
		}
	}

	public String getQualification(String qualCode) {
		Collection qualType = null;
		try {
			Object[] params = { qualCode };
			String queryString = sql_QUALIFICATIONS;
			qualType = getApasJdbcTemplate().query(queryString, params, new QualificationExtractor());
		} catch (Exception e) {
			System.out.println("Error while get the qualification type");
			e.printStackTrace();
		}
		HashMap qualString = null;
		Iterator it = qualType.iterator();
		if (it.hasNext()) {
			qualString = (HashMap) it.next();
		}
		// System.out.println(qualString.get("qual_type").toString());
		return qualString.get("qual_type").toString();
	}

	private class QualificationExtractor implements RowMapper {
		public Object mapRow(ResultSet rs, int row) throws SQLException {
			HashMap qualcode = new HashMap(1);
			qualcode.put("qual_type", (rs.getString(1)));
			return qualcode;
		}
	}

	public Rule getRule(long ruleId) {
		Rule rule = null;
		try {
			rule = getHibernateTemplate().get(Rule.class, ruleId);
			rule.populateTokenExpression();
			rule.getIntendedUseString();
			rule.getCountries();
			for(Country country : rule.getCountries()) {
				country.toString();
			}
			System.out.println("Ashwin Node Name is "+rule.getNode().getName());
			List<Scenario> scenarioList = rule.getScenarios();
			for (Scenario sc : scenarioList) {
				sc.populateTokenExpression();
				// setExpressionForScenario(sc);
				List<Leaf> leafList = sc.getLeaves();
				System.out.println(leafList.get(0).getId() + " OH " + leafList.get(0).getRuleExpressionType());
				// setPartnerTypeForLeaf(leafList.get(0));
				// setExpressionForLeaf(leafList.get(0));
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return rule;
	}
	
	public boolean deleteRule(Integer[] ruleIds) {
		try {
			DeleteRule notificationRemoved = new DeleteRule(apasJdbcTemplate);
			Map inputParams = new HashMap();
			inputParams.put(DeleteRule.I_RULE_TBL, new JavaIntArrayToOracleArrayConverter(ruleIds, "PSE_RULE_ID_TYPE"));
			System.out.println("Executing Proc: " + DeleteRule.PROC_NAME + " with Input Params: " + inputParams);
			StopWatch sw = new StopWatch();
			sw.start(DeleteRule.PROC_NAME);
			Map outputParams= notificationRemoved.execute(inputParams);
			sw.stop();
			System.out.println("Executed Proc in " + sw.getTotalTimeSeconds() + " seconds");
			String errorMsg = (String) outputParams.get(DeleteRule.O_ERROR_MSG);
			BigDecimal errorCode = (BigDecimal) outputParams.get(DeleteRule.O_ERROR_CODE);
			if (errorCode.intValue() == -1) {
				return false;
			}
			return true;
		} catch (Exception e) {
			if (e instanceof DAOException) {
				logger.error("Encountered DAOException :: " + e + " in Delete Rule");
				e.printStackTrace();
				throw (DAOException) e;
			} else {
				logger.error("Encountered exception: " + e + " in Delete Node.");
				e.printStackTrace();
				throw new DAOSystemException(ERROR_ADMIN, e);
			}
		}
	}

	private class DeleteRule extends StoredProcedure {
		private static final String PROC_NAME = "PSE_BUSINESS_RULE_PKG.delete_rule_pr";
		public static final String I_RULE_TBL = "i_rule_tbl";
		public static final String O_ERROR_CODE = "o_error_code";
		public static final String O_ERROR_MSG = "o_error_msg";

		public DeleteRule(JdbcTemplate jdbcTemplate) {
			super(jdbcTemplate, PROC_NAME);
			setFunction(false);
			declareParameter(new SqlParameter(I_RULE_TBL, OracleTypes.ARRAY));
			declareParameter(new SqlOutParameter(O_ERROR_CODE, OracleTypes.NUMERIC));
			declareParameter(new SqlOutParameter(O_ERROR_MSG, OracleTypes.VARCHAR));
			compile();
		}
	}

	private class JavaIntArrayToOracleArrayConverter extends AbstractSqlTypeValue {
		Integer[] itemsArray = null;
		String columnDescriptor = null;

		public JavaIntArrayToOracleArrayConverter(Integer[] items, String descriptor) {
			this.itemsArray = items;
			this.columnDescriptor = descriptor;
		}

		public Object createTypeValue(Connection underlyingConn, int type, String typeName) throws SQLException {
			ARRAY dbArray = null;
			try {
				Connection ocon = getApasJdbcTemplate().getNativeJdbcExtractor().getNativeConnection(underlyingConn);
				ArrayDescriptor arrayDesc = ArrayDescriptor.createDescriptor(columnDescriptor, ocon);
				dbArray = new ARRAY(arrayDesc, ocon, itemsArray);
			} catch (Exception e) {
				e.printStackTrace();
			}
			return dbArray;
		}
	}

	public void setExpressionForScenario(Scenario scenario) {
		Expression expression = new Expression();
		List<Token> tokens = new ArrayList<Token>();
		OrCondition or = new OrCondition();
		AndCondition and = new AndCondition();
		EndToken endToken = new EndToken();
		StartToken startToken = new StartToken();
		InCondition in = new InCondition();
		String strExpression = scenario.getExpression();
		StringTokenizer st = new StringTokenizer(strExpression);
		while (st.hasMoreTokens()) {
			String nextValue = st.nextToken();
			if (nextValue.equals(startToken.getTokenValue())) {
				tokens.add(startToken);
			} else if (nextValue.equals(endToken.getTokenValue())) {
				tokens.add(endToken);
			} else if (nextValue.equals(and.getTokenValue())) {
				tokens.add(and);
			} else if (nextValue.equals(or.getTokenValue())) {
				tokens.add(or);
			} else {
				Leaf leafToken = new Leaf();
				leafToken.setId(Long.decode(nextValue));
				tokens.add(leafToken);
			}
		}
		for (Token tk : tokens) {
			System.out.print(tk.getTokenValue() + ",");
		}
		expression.setTokens(tokens);
		scenario.setScenarioExpression(expression);
	}

	public void setExpressionForLeaf(Leaf leaf) {
		Expression expression = new Expression();
		List<Token> tokens = new ArrayList<Token>();
		OrCondition or = new OrCondition();
		AndCondition and = new AndCondition();
		EndToken endToken = new EndToken();
		StartToken startToken = new StartToken();
		InCondition inToken = new InCondition();
		String strExpression = leaf.getExpression();
		StringTokenizer st = new StringTokenizer(strExpression);
		while (st.hasMoreTokens()) {
			String nextValue = st.nextToken();
			if (nextValue.equals(startToken.getTokenValue())) {
				tokens.add(startToken);
			} else if (nextValue.equals(endToken.getTokenValue())) {
				tokens.add(endToken);
			} else if (nextValue.equals(and.getTokenValue())) {
				tokens.add(and);
			} else if (nextValue.equals(or.getTokenValue())) {
				tokens.add(or);
			} else {
				String strQual = null;
				strQual = nextValue.replaceAll("'", "");
				strQual = getQualification(strQual);
				if (strQual.equals("AUTH")) {
					Authorization authToken = new Authorization();
					authToken.setCode(nextValue.toString());
					tokens.add(authToken);
				} else if (strQual.equals("SPECIAL")) {
					Specialization specToken = new Specialization();
					specToken.setCode(nextValue.toString());
					tokens.add(specToken);
				} else if (strQual.equals("CERT")) {
					Certification certToken = new Certification();
					certToken.setCode(nextValue.toString());
					tokens.add(certToken);
				}
			}
		}
		// set Qualification expression
		LeafExpressionValidator leafExpressionValidator = new LeafExpressionValidator();
		ExpressionType leafExpressionType = new ExpressionType();
		leafExpressionType.setValidator(leafExpressionValidator);
		expression.setExpressionType(leafExpressionType);
		expression.setTokens(tokens);
		leaf.setLeafExpression(expression);
		for (Token tk : tokens) {
			System.out.print(tk.getTokenValue() + ",");
		}
		// set the leaf expression
		/*
		 * StringToken partnerExpression = new StringToken(); partnerExpression.setTokenValue (leaf.getPartnerTypeExpression().toString());
		 * 
		 * StringToken qualExpression = new StringToken(); qualExpression.setTokenValue (leaf.getQualificationExpression().toString());
		 * 
		 * Expression leafExpn = new Expression(); List<Token> leafTokens = new ArrayList<Token>();
		 * 
		 * leafTokens.add(partnerExpression); leafTokens.add(and); leafTokens.add(qualExpression); StringToken qualCountry = new StringToken();
		 * qualCountry.setTokenValue(leaf.getQualRuleCountry()); leafTokens.add(inToken); leafTokens.add(qualCountry);
		 * 
		 * leafExpn.setTokens(leafTokens); leaf.setLeafExpression(leafExpn);
		 * 
		 * System.out.println("The leaf Expression is \n"+leaf.getLeafExpression( ).toString());
		 */
	}

	public void setPartnerTypeForLeaf(Leaf leaf) {
		String strExpression = leaf.getPartnerType();
		Expression expression = new Expression();
		List<Token> tokens = new ArrayList<Token>();
		OrCondition or = new OrCondition();
		System.out.println(strExpression);
		StringTokenizer st = new StringTokenizer(strExpression);
		while (st.hasMoreTokens()) {
			String nextValue = st.nextToken();
			if (nextValue.equals(or.getTokenValue())) {
				tokens.add(or);
			} else {
				PartnerType partnerTypeToken = new PartnerType();
				partnerTypeToken.setCode(nextValue);
				tokens.add(partnerTypeToken);
			}
		}
		for (Token tk : tokens) {
			System.out.print(tk.getTokenValue() + ",");
		}
		System.out.println("\n");
		PartnerTypeExpressionValidator partnerExpressionValidator = new PartnerTypeExpressionValidator();
		ExpressionType partnerExpressionType = new ExpressionType();
		partnerExpressionType.setValidator(partnerExpressionValidator);
		expression.setExpressionType(partnerExpressionType);
		expression.setTokens(tokens);
		leaf.setPartnerTypeExpression(expression);
	}

	public void saveRule(String userID, final Rule rule, final Long nodeID) {
		Map<String, Object> iMap = new HashMap<String, Object>();
		iMap.put(SaveOrUpdateRulePr.I_USER_ID, userID);
		/*
		 * 
		 * 0. RULE_ID NUMBER, 1. RULE_NAME VARCHAR2(40 BYTE), 2. RULE_TYPE VARCHAR2(10 BYTE) , 3. RULE_EXPRESSION VARCHAR2(4000 BYTE), 4. PARENT_RULE_ID NUMBER, 5.
		 * NODE_ID NUMBER, 6. RULE_EXPRESSION_TYPE VARCHAR2(20 BYTE), 7. PARTNER_TYPE VARCHAR2(50 BYTE), 8. ARITHMETIC_OPERAND VARCHAR2(20 BYTE), 9. ARITHMETIC_OPERATOR
		 * VARCHAR2(10 BYTE), 10. ARITHMETIC_VALUE VARCHAR2(40 BYTE), 11. QUAL_RULE_FOR VARCHAR2(2 BYTE), 12. QUAL_RULE_COUNTRY VARCHAR2(1 BYTE), 13. EFF_START_DATE DATE,
		 * 14. EFF_END_DATE DATE, 15. RULE_STATUS VARCHAR2(1 BYTE), 16. VERSION_ID NUMBER(6,3), 17. MOD_TYPE VARCHAR2(1 BYTE)
		 */
		final List<Object[]> rules = getRules(rule, nodeID, userID);
		iMap.put(SaveOrUpdateRulePr.I_RULE_ID, rule.getId());
		iMap.put(SaveOrUpdateRulePr.I_RULE_TBL, new AbstractSqlTypeValue() {
			public Object createTypeValue(Connection con, int type, String typeName) throws SQLException {
				Connection ocon = getApasJdbcTemplate().getNativeJdbcExtractor().getNativeConnection(con);
				StructDescriptor descriptor = StructDescriptor.createDescriptor("SDS_ADMIN.PSE_RULE_OBJ", ocon);
				Object[] rulesArray = new Object[rules.size()];
				for (int i = 0; i < rulesArray.length; i++) {
					Object[] ruleObj = rules.get(i);
					STRUCT struct = new STRUCT(descriptor, ocon, ruleObj);
					rulesArray[i] = struct;
				}
				ArrayDescriptor desc = ArrayDescriptor.createDescriptor("PSE_RULE_TBL", ocon);
				return new ARRAY(desc, ocon, rulesArray);
			}
		});
		SaveOrUpdateRulePr saveOrUpdateRulePr = new SaveOrUpdateRulePr(getApasJdbcTemplate());
		saveOrUpdateRulePr.execute(iMap);
		updateRuleMapPr(rule, userID);
	}

	public Long getRuleID() {
		return getApasJdbcTemplate().queryForLong("SELECT SD_RULE_ID_SEQUENCE.NEXTVAL FROM dual");
	}

	public List<Object[]> getRules(final Rule rule, final Long nodeID, final String userID) {
		List<Object[]> objects = new ArrayList<Object[]>();
		Object[] ruleObjects = new Object[18];
		if (rule.getId() == null) {
			ruleObjects[17] = "I";
			rule.setId(getRuleID());
			ruleObjects[0] = rule.getId();
		} else {
			ruleObjects[17] = "U";
			ruleObjects[0] = rule.getId();
		}
		ruleObjects[1] = rule.getRuleName();
		ruleObjects[2] = "RULE";
		List<Object[]> scenarios = new ArrayList<Object[]>();
		List<Object[]> leafs = new ArrayList<Object[]>();
		ruleObjects[3] = getRuleExpression(rule, scenarios, leafs, nodeID, userID);
		ruleObjects[4] = null;
		ruleObjects[5] = nodeID;
		ruleObjects[6] = null;
		ruleObjects[7] = null;
		ruleObjects[8] = null;
		ruleObjects[9] = null;
		ruleObjects[10] = null;
		ruleObjects[11] = rule.getRouteToMarket();
		ruleObjects[12] = null;
		ruleObjects[13] = new Date(rule.getEffectiveStartDate().getTime());
		ruleObjects[14] = (rule.getEffectiveEndDate() == null ? null :new Date(rule.getEffectiveEndDate().getTime()));
		ruleObjects[15] = "A";
		ruleObjects[16] = "1";
		objects.add(ruleObjects);
		objects.addAll(scenarios);
		objects.addAll(leafs);
		return objects;
	}

	private String getRuleExpression(Rule rule, List<Object[]> scenarios, List<Object[]> leafs, final Long nodeID, final String userID) {
		StringBuilder rv = new StringBuilder(" ");
		for (int i = 0; i < rule.getTokenExpressions().size(); i++) {
			Token token = rule.getTokenExpressions().get(i);
			if (token instanceof ParenthesisToken || token instanceof ConditionalToken) {
				rv.append(" ").append(token.getTokenValue()).append(" ");
			} else {
				Scenario scenario = (Scenario) token;
				scenario.setRule(rule);
				Object[] scenarioObjects = new Object[18];
				if (scenario.getId() == null) {
					scenarioObjects[17] = "I";
					scenario.setId(getRuleID());
					scenarioObjects[0] = scenario.getId();
				} else {
					scenarioObjects[17] = "U";
					scenarioObjects[0] = scenario.getId();
				}
				rv.append(scenario.getId());
				scenarioObjects[1] = scenario.getRuleName();
				scenarioObjects[2] = "SCENARIO";
				scenarioObjects[3] = getScenarioExpression(scenario, leafs, nodeID, userID, rule);
				scenarioObjects[4] = scenario.getRule().getId();
				scenarioObjects[5] = nodeID;
				scenarioObjects[6] = null;
				scenarioObjects[7] = null;
				scenarioObjects[8] = null;
				scenarioObjects[9] = null;
				scenarioObjects[10] = null;
				scenarioObjects[11] = null;
				scenarioObjects[12] = null;
				scenarioObjects[13] = new Date(rule.getEffectiveStartDate().getTime());
				scenarioObjects[14] = (rule.getEffectiveEndDate() == null ? null :new Date(rule.getEffectiveEndDate().getTime()));
				scenarioObjects[15] = "A";
				scenarioObjects[16] = "1";
				scenarios.add(scenarioObjects);
			}
		}
		return rv.toString();
	}

	private String getScenarioExpression(Scenario scenario, List<Object[]> leafs, final Long nodeID, final String userID, Rule rule) {
		StringBuilder rv = new StringBuilder(" ");
		for (int i = 0; i < scenario.getTokenExpressions().size(); i++) {
			Token token = scenario.getTokenExpressions().get(i);
			if (token instanceof ParenthesisToken || token instanceof ConditionalToken) {
				rv.append(" ").append(token.getTokenValue()).append(" ");
			} else {
				Leaf leaf = (Leaf) token;
				leaf.setScenario(scenario);
				Object[] leafObjects = new Object[18];
				if (leaf.getId() == null) {
					leafObjects[17] = "I";
					leaf.setId(getRuleID());
					leafObjects[0] = leaf.getId();
				} else {
					leafObjects[17] = "U";
					leafObjects[0] = leaf.getId();
				}
				rv.append(leaf.getId());
				leafObjects[1] = leaf.getRuleName();
				leafObjects[2] = "LEAF";
				leafObjects[3] = leaf.getExpression();
				leafObjects[4] = scenario.getId();
				leafObjects[5] = nodeID;
				leafObjects[6] = leaf.getRuleExpressionType();
				leafObjects[7] = leaf.getPartnerType();
				leafObjects[8] = ("ARITHMETIC".equals(leaf.getRuleExpressionType()) ? "END_CUSTOMER_TYPE" : null);
				leafObjects[9] = ("ARITHMETIC".equals(leaf.getRuleExpressionType()) ? "EQ" : null);
				leafObjects[10] = ("ARITHMETIC".equals(leaf.getRuleExpressionType()) ? "G3100" : null);
				leafObjects[11] = leaf.getQualRuleFor();
				leafObjects[12] = leaf.getQualRuleCountry();
				leafObjects[13] = new Date(rule.getEffectiveStartDate().getTime());
				leafObjects[14] = (rule.getEffectiveEndDate() == null ? null :new Date(rule.getEffectiveEndDate().getTime()));
				leafObjects[15] = "A";
				leafObjects[16] = "1";
				leafs.add(leafObjects);
			}
		}
		return rv.toString();
	}

	private class SaveOrUpdateRulePr extends StoredProcedure {
		private static final String PROC_NAME = "PSE_BUSINESS_RULE_PKG.SAVE_RULE_DETAILS";
		private static final String I_USER_ID = "i_user_id";
		private static final String I_RULE_ID = "i_rule_id";
		private static final String I_RULE_TBL = "i_rule_tbl";
		private static final String O_ERROR_CODE = "o_error_code";
		private static final String O_ERROR_MSG = "o_error_msg";

		private SaveOrUpdateRulePr(JdbcTemplate jdbcTemplate) {
			super(jdbcTemplate, PROC_NAME);
			setFunction(false);
			declareParameter(new SqlParameter(SaveOrUpdateRulePr.I_USER_ID, OracleTypes.VARCHAR));
			declareParameter(new SqlParameter(SaveOrUpdateRulePr.I_RULE_ID, OracleTypes.NUMERIC));
			declareParameter(new SqlParameter(SaveOrUpdateRulePr.I_RULE_TBL, OracleTypes.ARRAY, "PSE_RULE_TBL"));
			declareParameter(new SqlOutParameter(SaveOrUpdateRulePr.O_ERROR_CODE, OracleTypes.NUMBER));
			declareParameter(new SqlOutParameter(SaveOrUpdateRulePr.O_ERROR_MSG, OracleTypes.VARCHAR));
			compile();
		}
	}

	private void updateRuleMapPr(final Rule rule, String userID) {
		Map<String, Object> iMap = new HashMap<String, Object>();
		iMap.put(SaveOrUpdateRuleMapPr.I_USER_ID, userID);
		iMap.put(SaveOrUpdateRuleMapPr.I_RULE_ID, rule.getId());
		iMap.put(SaveOrUpdateRuleMapPr.I_INTENDED_USE_TBL, new AbstractSqlTypeValue() {
			public Object createTypeValue(Connection con, int type, String typeName) throws SQLException {
				Connection ocon = getApasJdbcTemplate().getNativeJdbcExtractor().getNativeConnection(con);
				ArrayDescriptor desc = ArrayDescriptor.createDescriptor("PSE_RULE_MAP_TYPE", ocon);
				return new ARRAY(desc, ocon, rule.getIntendedUse().toArray());
			}
		});
		iMap.put(SaveOrUpdateRuleMapPr.I_COUNTRY_TBL, new AbstractSqlTypeValue() {
			public Object createTypeValue(Connection con, int type, String typeName) throws SQLException {
				Connection ocon = getApasJdbcTemplate().getNativeJdbcExtractor().getNativeConnection(con);
				StructDescriptor descriptor = StructDescriptor.createDescriptor("SDS_ADMIN.PSE_RULE_MAP_OBJ", ocon);
				Object[] rules = new Object[rule.getCountries().size()];
				for (int i = 0; i < rule.getCountries().size(); i++) {
					Country country = rule.getCountries().get(i);
					Object[] countryObj = { rule.getId(), country.getCountry(), country.getUsageType().toString() };
					STRUCT struct = new STRUCT(descriptor, ocon, countryObj);
					rules[i] = struct;
				}
				ArrayDescriptor desc = ArrayDescriptor.createDescriptor("PSE_RULE_MAP_TBL", ocon);
				return new ARRAY(desc, ocon, rules);
			}
		});
		SaveOrUpdateRuleMapPr updateRuleMapPr = new SaveOrUpdateRuleMapPr(getApasJdbcTemplate());
		updateRuleMapPr.execute(iMap);
	}

	private class SaveOrUpdateRuleMapPr extends StoredProcedure {
		private static final String PROC_NAME = "PSE_BUSINESS_RULE_PKG.SAVE_MAP_DETAILS";
		private static final String I_USER_ID = "i_user_id";
		private static final String I_RULE_ID = "i_rule_id";
		private static final String I_INTENDED_USE_TBL = "i_int_rule_map_tbl";
		private static final String I_COUNTRY_TBL = "i_pse_rule_map_tbl";
		private static final String O_ERROR_CODE = "o_error_code";
		private static final String O_ERROR_MSG = "o_error_msg";

		private SaveOrUpdateRuleMapPr(JdbcTemplate jdbcTemplate) {
			super(jdbcTemplate, PROC_NAME);
			setFunction(false);
			declareParameter(new SqlParameter(SaveOrUpdateRuleMapPr.I_USER_ID, OracleTypes.VARCHAR));
			declareParameter(new SqlParameter(SaveOrUpdateRuleMapPr.I_RULE_ID, OracleTypes.NUMERIC));
			declareParameter(new SqlParameter(SaveOrUpdateRuleMapPr.I_INTENDED_USE_TBL, OracleTypes.ARRAY, "PSE_RULE_MAP_TYPE"));
			declareParameter(new SqlParameter(SaveOrUpdateRuleMapPr.I_COUNTRY_TBL, OracleTypes.ARRAY, "PSE_RULE_MAP_TBL"));
			declareParameter(new SqlOutParameter(SaveOrUpdateRuleMapPr.O_ERROR_CODE, OracleTypes.NUMBER));
			declareParameter(new SqlOutParameter(SaveOrUpdateRuleMapPr.O_ERROR_MSG, OracleTypes.VARCHAR));
			compile();
		}
	}
}